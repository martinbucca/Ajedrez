impl puede_capturar for pieza{
    fn puede_capturar(self.posibles_movientos, posicion_oponente) {
        for posibles_movientos in posibles_movientos{
            if posibles_moviento == posicion_oponente{
                return true
            }
        }
        return false
    }
}






enum Moviento {
    Movimiento_diagonal(cant),
    Movimiento_vertical(cant),
    Movimiento_horizonatl(cant),
    Movimiento_l
}



trait PosiblesMovientos {
    fn posibles_movimientos(&self) -> Vec<Position>;
}

impl PosiblesMovientos for Alfil{
    fn posibles_movientos(self) -> Vec<Position> {

    }
}

impl PosiblesMovientos for Torre{
    fn posibles_movientos(self) -> Vec<Position> {
        let vec: Vec<Position> = vec![];
        for i in 1..=8{
            vec.push(Position{x:self.position.x, y:i});
            vec.push(Position{x:i, y:self.position.y});
        }
        vec
    }
}
impl PosiblesMovientos for Rey{
    fn posibles_movientos(self) -> Vec<Position> {
        
    }
}
impl PosiblesMovientos for Dama{
    fn posibles_movientos(self) -> Vec<Position> {
        
    }
}
impl PosiblesMovientos for PeonNegro{
    fn posibles_movientos(self) -> Vec<Position> {
        let vec: Vec<Position> = vec![];

    }
}

impl PosiblesMovientos for PeonBlanco{
    fn posibles_movientos(self) -> Vec<Position> {
        let vec: Vec<Position> = vec![];

    }
}

impl PosiblesMovientos for Caballo{
    fn posibles_movientos(self) -> Vec<Position> {
        
    }
}





struct Chessboard {
    black: Piece,
    white: Piece,
}

enum PieceColor{
    Black,
    Withe
}
enum Piece{
    Alfil,
    Rey,
    Dama,
    Peon,
    Torre,
    Caballo,
}

struct Alfil{
    position: Position,
    color: PieceColor
}

struct Rey{
    position: Position,
    color: PieceColor,
}

struct Dama{
    position: Position,
    color: PieceColor,
}

enum Peon{
    PeonBlanco,
    PeonNegro,
}

struct PeonBlanco{
    position: Position,
}

struct PeonNegro{
    position: Position,
}
struct Torre{
    position: Position,
    color: PieceColor,
}

struct Caballo{
    position: Position,
    color: PieceColor,
}


fn create_chessboard(table: &Vec<Vec<char>>) -> Chessboard{
    let mut black: Piece = Piece::Rey;
    let mut white: Piece = ;
    for (number_of_row, row) in table.into_iter().enumerate(){
        for (number_of_column, char) in row.into_iter().enumerate(){
            let position = Postion {x: number_of_row + 1, y: number_of_column + 1};
            match char {
                '_' => (),
                'T' => Piece::Torre{position, color: PieceColor::Black},
                'A' => Piece::Alfil{position, color: PieceColor::Black},
                'R' => Piece::Rey{position, color: PieceColor::Black},
                'D' => Piece::Dama{position, color: PieceColor::Black},
                'C' => Piece::Caballo{position, color: PieceColor::Black},
                'P' => Piece::Peon::PeonNegro{position, color: PieceColor::Black},
                't' => Piece::Torre{position, color: PieceColor::White},
                'a' => Piece::Alfil{position, color: PieceColor::White},
                'r' => Piece::Rey{position, color: PieceColor::White},
                'd' => Piece::Dama{position, color: PieceColor::White},
                'c' => Piece::Caballo{position, color: PieceColor::White},
                'p' => Piece::Peon::PeonBlanco{position, color: PieceColor::White},
            }
        }
    }
    Chessboard{black, white}

}